"""
NOVA - Code Architect & Developer
Expert code generator and architect
"""

import os
import json
import re
from typing import Dict, Any, List, Optional
from pathlib import Path

from src.core.agent import AsyncAgent
from src.core.message import AgentMessage, TaskResult
from src.core.model_router import TaskType


class Nova(AsyncAgent):
    """
    NOVA - Code Architect & Developer

    Responsibilities:
    - Generate production-ready code
    - Design architecture
    - Implement features
    - Refactor and optimize
    """

    def __init__(self):
        super().__init__(
            name="Nova",
            role="Code Architect & Developer",
            model=os.getenv("CODE_MODEL", "glm-5"),
            api_key=os.getenv("GLM_API_KEY"),
            api_base=os.getenv("GLM_API_BASE") or os.getenv("ZAI_OPENAI_BASE_URL", "https://api.z.ai/api/openai/v1")
        )

        self.output_dir = Path("app-output")
        self.output_dir.mkdir(parents=True, exist_ok=True)

    async def process(self, message: AgentMessage) -> TaskResult:
        """Process code generation task"""

        self._log("ðŸ’» Processing code generation task...")

        context = message.content.get("context", {})
        iteration = message.content.get("iteration", 1)
        runtime_hints = message.content.get("runtime_hints", {})
        if not isinstance(runtime_hints, dict):
            runtime_hints = {}
        fallback_streak = int(runtime_hints.get("nova_no_output_streak", 0) or 0)
        prefer_cost = bool(runtime_hints.get("prefer_cost", False))
        skip_remote_after_streak = max(3, int(os.getenv("NOVA_SKIP_REMOTE_AFTER_STREAK", "6")))
        remote_retry_interval = max(2, int(os.getenv("NOVA_REMOTE_RETRY_INTERVAL", "10")))
        force_local_fallback = fallback_streak >= skip_remote_after_streak and (iteration % remote_retry_interval != 0)

        # Get previous feedback
        feedback_history = context.get("feedback_history", [])
        previous_issues = []
        for fb in feedback_history[-3:]:  # Last 3 feedbacks
            previous_issues.extend(fb.get("issues", []))

        # Build prompt
        prompt = self._build_prompt(context, iteration, previous_issues)

        # Call API
        messages = [
            {"role": "system", "content": self._get_system_prompt()},
            {"role": "user", "content": prompt}
        ]

        importance = message.priority.value if hasattr(message, "priority") else "normal"
        used_repair_pass = False
        used_local_scaffold = False
        if force_local_fallback:
            used_local_scaffold = True
            self._log(
                f"ðŸ§± Streak fallback mode active (no-output streak={fallback_streak}), "
                "skipping remote generation this cycle."
            )
            code_data = self._build_local_scaffold(context=context, iteration=iteration)
        else:
            response = await self.call_api(
                messages,
                task_type=TaskType.CODE_GENERATION,
                importance=importance,
                prefer_cost=prefer_cost,
            )

            if "error" in response:
                return self.create_result(False, {"error": response["error"]})

            code_data = self._extract_code_payload(response)

            if not self._is_output_usable(code_data):
                used_repair_pass = True
                self._log("âš ï¸ Primary response missing deployable files, running strict repair pass...")
                repair_messages = [
                    {"role": "system", "content": self._get_system_prompt()},
                    {"role": "user", "content": self._build_repair_prompt(context, iteration, previous_issues)},
                ]
                repair_response = await self.call_api(
                    repair_messages,
                    task_type=TaskType.CODE_GENERATION,
                    importance=importance,
                    prefer_speed=True,
                    prefer_cost=prefer_cost,
                )
                if "error" not in repair_response:
                    repaired = self._extract_code_payload(repair_response)
                    if self._is_output_usable(repaired):
                        code_data = repaired

            if not self._is_output_usable(code_data):
                used_local_scaffold = True
                self._log("ðŸ§± Repair pass still empty, using deterministic local scaffold.")
                code_data = self._build_local_scaffold(context=context, iteration=iteration)

        saved_files = self._save_files_from_payload(code_data)

        if not saved_files:
            return self.create_result(
                success=False,
                output={"error": "No deployable files were generated by Nova"},
                issues=["No files generated"],
            )

        score = self._calculate_score(code_data)
        if used_local_scaffold:
            score = min(score, 6.5)

        issues: List[str] = []
        if used_local_scaffold:
            issues.append("Used local scaffold fallback")

        suggestions = list(code_data.get("improvements", [])) if isinstance(code_data.get("improvements", []), list) else []
        if used_local_scaffold:
            suggestions.append("Investigate upstream prompt/system directives causing non-deployable LLM output.")

        return self.create_result(
            success=True,
            output={
                "files": saved_files,
                "structure": code_data.get("structure", {}),
                "dependencies": code_data.get("dependencies", []),
                "generation_flags": {
                    "repair_pass": used_repair_pass,
                    "local_scaffold_fallback": used_local_scaffold,
                },
            },
            score=score,
            issues=issues,
            suggestions=suggestions,
        )

    def _get_system_prompt(self) -> str:
        return """You are NOVA, an elite Code Architect and Developer.

Your expertise:
- Production-ready code
- Clean architecture (SOLID, DRY, KISS)
- Modern best practices
- Performance optimization
- Security-first mindset

When generating code:
1. Structure your response as JSON with this format:
{
    "files": [
        {"path": "index.html", "content": "..."},
        {"path": "styles.css", "content": "..."},
        {"path": "app.js", "content": "..."}
    ],
    "structure": {
        "type": "spa",
        "framework": "vanilla",
        "features": ["dark-mode", "responsive", "accessible"]
    },
    "dependencies": [],
    "improvements": ["suggestion1", "suggestion2"]
}

2. Always include:
   - Complete, working code (no placeholders)
   - Proper error handling
   - Accessibility features (ARIA, semantic HTML)
   - Responsive design
   - Modern CSS (Grid, Flexbox, CSS Variables)
   - Clean JavaScript (ES6+)

3. Code quality standards:
   - Semantic HTML5
   - BEM or similar CSS methodology
   - Modular JavaScript
   - Comments for complex logic
   - No inline styles (use CSS)
   - No hardcoded values (use CSS variables)

4. OUTPUT RULES (MANDATORY):
   - Return JSON only (no markdown fences, no prose)
   - "files" must contain at least index.html, styles.css, app.js
   - Every file entry must have "path" and "content"

Generate the BEST code possible. No compromises."""

    def _build_prompt(self, context: Dict, iteration: int, previous_issues: List[str]) -> str:
        project_goal = context.get("project_goal", "Build a modern web application")
        files = context.get("files", {})

        prompt = f"""PROJECT GOAL: {project_goal}
ITERATION: {iteration}

"""

        if previous_issues:
            prompt += f"""PREVIOUS ISSUES TO FIX:
{chr(10).join(f'- {issue}' for issue in previous_issues)}

"""

        if files:
            current_files = ", ".join(sorted(files.keys())[:8])
            prompt += f"CURRENT FILES: {current_files}\n\n"

        if iteration == 1:
            prompt += """Generate a complete, production-ready web application.
Include all necessary HTML, CSS, and JavaScript files.
Make it beautiful, functional, and modern."""
        else:
            prompt += """IMPROVE the existing code based on feedback.
Address all issues mentioned above.
Enhance UI/UX, add missing features, improve code quality."""

        return prompt

    def _build_repair_prompt(self, context: Dict, iteration: int, previous_issues: List[str]) -> str:
        project_goal = context.get("project_goal", "Build a modern web application")
        issue_block = "\n".join(f"- {issue}" for issue in previous_issues) if previous_issues else "- Ensure valid structured output."
        return f"""PROJECT GOAL: {project_goal}
ITERATION: {iteration}

PREVIOUS ISSUES TO FIX:
{issue_block}

Your previous response was not deployable. Generate deployable frontend code now.

MANDATORY:
- Return a single valid JSON object only.
- Include files: index.html, styles.css, app.js.
- Ensure index.html references styles.css and app.js.
- No markdown fences, no explanation text, no comments outside JSON."""

    def _calculate_score(self, code_data: Dict) -> float:
        """Calculate code quality score"""
        score = 7.0  # Base score

        files = code_data.get("files", [])

        # More files = more complete = higher score
        if len(files) >= 3:
            score += 0.5

        # Has structure definition
        if code_data.get("structure"):
            score += 0.5

        # Has dependencies listed
        if code_data.get("dependencies"):
            score += 0.3

        # Has improvement suggestions
        if code_data.get("improvements"):
            score += 0.5

        # Cap at 10
        return min(score, 10.0)

    def _normalize_files_payload(self, code_data: Dict[str, Any]) -> Dict[str, Any]:
        """Normalize non-standard model responses into canonical files[] payload."""
        if not isinstance(code_data, dict):
            return {"files": []}

        files = code_data.get("files")
        normalized_files: List[Dict[str, str]] = []
        if isinstance(files, dict):
            for path, content in files.items():
                normalized_files.append({
                    "path": str(path),
                    "content": str(content) if content is not None else "",
                })
        elif isinstance(files, list):
            for entry in files:
                if isinstance(entry, dict):
                    file_path = entry.get("path") or entry.get("name") or entry.get("file")
                    file_content = entry.get("content")
                    if file_content is None:
                        file_content = entry.get("code") or entry.get("text")
                    if file_path and isinstance(file_content, str):
                        normalized_files.append({"path": str(file_path), "content": file_content})
        if normalized_files:
            code_data["files"] = normalized_files
            return code_data

        synthesized: List[Dict[str, str]] = []
        html_content = code_data.get("html") or code_data.get("index_html") or code_data.get("index")
        css_content = code_data.get("css") or code_data.get("styles")
        js_content = code_data.get("js") or code_data.get("javascript") or code_data.get("script")

        if isinstance(html_content, str) and html_content.strip():
            synthesized.append({"path": "index.html", "content": html_content})
        if isinstance(css_content, str) and css_content.strip():
            synthesized.append({"path": "styles.css", "content": css_content})
        if isinstance(js_content, str) and js_content.strip():
            synthesized.append({"path": "app.js", "content": js_content})

        raw_content = code_data.get("raw")
        if not synthesized and isinstance(raw_content, str) and raw_content.strip():
            if "<html" in raw_content.lower() or "<body" in raw_content.lower():
                synthesized.append({"path": "index.html", "content": raw_content})

        if synthesized:
            code_data["files"] = synthesized
        return code_data

    def _extract_code_payload(self, response: Dict[str, Any]) -> Dict[str, Any]:
        """Extract robust code payload from model response."""
        parsed = self._parse_json_response(response)
        if not parsed.get("parse_error"):
            return self._normalize_files_payload(parsed)

        text = self._extract_text_response(response)
        recovered = self._extract_json_object(text)
        if recovered is not None:
            return self._normalize_files_payload(recovered)

        # Keep raw text for final HTML fallback if needed.
        return self._normalize_files_payload({"raw": text, "parse_error": True, "files": []})

    def _extract_text_response(self, response: Dict[str, Any]) -> str:
        """Extract text content from heterogeneous model payloads."""
        try:
            content = response.get("choices", [{}])[0].get("message", {}).get("content", "")
            if isinstance(content, list):
                chunks = []
                for item in content:
                    if isinstance(item, dict):
                        text_value = item.get("text") or item.get("content")
                        if isinstance(text_value, str):
                            chunks.append(text_value)
                return "\n".join(chunks).strip()
            if isinstance(content, dict):
                maybe_text = content.get("text") or content.get("content")
                return str(maybe_text or "").strip()
            return str(content or "").strip()
        except Exception:
            return ""

    def _extract_json_object(self, text: str) -> Optional[Dict[str, Any]]:
        """Try to recover a JSON object from mixed text."""
        if not text:
            return None

        # Prefer explicit ```json fenced content first.
        fence_match = re.search(r"```json\s*(\{[\s\S]*?\})\s*```", text, flags=re.IGNORECASE)
        if fence_match:
            try:
                data = json.loads(fence_match.group(1))
                if isinstance(data, dict):
                    return data
            except Exception:
                pass

        decoder = json.JSONDecoder()
        for match in re.finditer(r"\{", text):
            start = match.start()
            try:
                candidate, _ = decoder.raw_decode(text[start:])
            except Exception:
                continue
            if isinstance(candidate, dict):
                if "files" in candidate or "html" in candidate or "index_html" in candidate:
                    return candidate
                # Keep first valid object as last resort.
                return candidate
        return None

    def _has_deployable_files(self, code_data: Dict[str, Any]) -> bool:
        files = code_data.get("files", [])
        return isinstance(files, list) and any(
            isinstance(item, dict)
            and isinstance(item.get("path"), str)
            and isinstance(item.get("content"), str)
            and item.get("content", "").strip()
            for item in files
        )

    def _is_output_usable(self, code_data: Dict[str, Any]) -> bool:
        """Ensure generated payload is actually usable for frontend deploy."""
        if not self._has_deployable_files(code_data):
            return False
        files = code_data.get("files", [])
        if not isinstance(files, list):
            return False

        file_map: Dict[str, str] = {}
        for item in files:
            if not isinstance(item, dict):
                continue
            path = str(item.get("path", "")).strip().lower()
            content = item.get("content")
            if isinstance(content, str):
                file_map[path] = content

        index_html = file_map.get("index.html", "")
        if not index_html.strip():
            return False

        html_lower = index_html.lower()
        if "[tool_call]" in html_lower or "filesystem_" in html_lower:
            return False
        if "<html" not in html_lower or "<body" not in html_lower:
            return False

        has_css_file = any(path.endswith(".css") for path in file_map.keys())
        has_js_file = any(path.endswith(".js") for path in file_map.keys())
        return has_css_file and has_js_file

    def _safe_output_path(self, relative_path: str) -> Optional[Path]:
        candidate = (self.output_dir / relative_path).resolve()
        output_root = self.output_dir.resolve()
        if not str(candidate).startswith(str(output_root)):
            return None
        return candidate

    def _save_files_from_payload(self, code_data: Dict[str, Any]) -> List[str]:
        saved_files: List[str] = []
        files = code_data.get("files", [])
        if not isinstance(files, list):
            return saved_files

        for file_info in files:
            if not isinstance(file_info, dict):
                continue
            file_path_raw = str(file_info.get("path", "")).strip()
            file_content = file_info.get("content")
            if not file_path_raw or not isinstance(file_content, str) or not file_content.strip():
                continue

            safe_relative = file_path_raw.replace("\\", "/").lstrip("/")
            safe_path = self._safe_output_path(safe_relative)
            if safe_path is None:
                self._log(f"âš ï¸ Skipped unsafe file path: {file_path_raw}")
                continue
            safe_path.parent.mkdir(parents=True, exist_ok=True)
            safe_path.write_text(file_content, encoding="utf-8")
            saved_files.append(str(safe_path))
            self._log(f"ðŸ“„ Saved: {safe_path}")

        return saved_files

    def _select_scaffold_pack(self, project_goal: str) -> str:
        goal = str(project_goal or "").lower()
        control_keywords = {"dashboard", "control", "agent", "monitor", "realtime", "automation"}
        studio_keywords = {"portfolio", "profile", "cv", "resume", "agency", "creative", "studio"}
        if any(word in goal for word in control_keywords):
            return "control"
        if any(word in goal for word in studio_keywords):
            return "studio"
        return "product"

    def _build_scaffold_variant(self, pack: str, escaped_goal: str) -> Dict[str, Any]:
        if pack == "control":
            html = f"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Automation Control Runtime</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <main class="shell">
    <header class="hero">
      <p class="badge">Control Runtime</p>
      <h1>Autonomous Agent Grid</h1>
      <p class="subtitle">{escaped_goal}</p>
      <div class="hero-actions">
        <button id="themeToggle" class="btn" aria-label="Toggle theme">Toggle theme</button>
        <span id="heartbeat" class="status">Heartbeat syncing...</span>
      </div>
    </header>
    <section class="panel-grid" aria-label="Agent overview">
      <article class="panel"><h2>Orion</h2><p>Orchestration loop and decision flow.</p></article>
      <article class="panel"><h2>Guardian</h2><p>Watchdog, recovery, and policy enforcement.</p></article>
      <article class="panel"><h2>Worker Agents</h2><p>NOVA, PIXEL, ECHO, CIPHER, FLUX execution state.</p></article>
    </section>
  </main>
  <script src="app.js"></script>
</body>
</html>
"""
            css = """:root {
  --bg: #f4f7ff;
  --surface: #ffffff;
  --text: #10182b;
  --muted: #5b6478;
  --accent: #1f6fff;
  --ok: #0f9960;
}
* { box-sizing: border-box; }
body {
  margin: 0;
  font-family: "IBM Plex Sans", "Segoe UI", sans-serif;
  color: var(--text);
  background: radial-gradient(circle at 0% 0%, #dce6ff, var(--bg) 40%);
}
.shell { max-width: 1080px; margin: 0 auto; padding: 2rem 1.2rem 3rem; }
.hero { display: grid; gap: 0.75rem; margin-bottom: 1.5rem; }
.badge { margin: 0; color: var(--accent); font-weight: 700; letter-spacing: 0.08em; text-transform: uppercase; }
h1 { margin: 0; font-size: clamp(1.9rem, 4vw, 2.9rem); }
.subtitle { margin: 0; color: var(--muted); max-width: 72ch; }
.hero-actions { display: flex; flex-wrap: wrap; gap: 0.6rem; align-items: center; }
.btn { border: 0; border-radius: 10px; padding: 0.65rem 1rem; background: var(--accent); color: #fff; cursor: pointer; }
.status { color: var(--ok); font-size: 0.92rem; font-weight: 600; }
.panel-grid { display: grid; gap: 1rem; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); }
.panel { background: var(--surface); border-radius: 14px; padding: 1rem; box-shadow: 0 10px 30px rgba(14, 34, 91, 0.08); }
.panel h2 { margin: 0 0 0.55rem; font-size: 1.08rem; }
.panel p { margin: 0; color: var(--muted); line-height: 1.55; }
body.dark {
  --bg: #10172a;
  --surface: #1b2740;
  --text: #e6edff;
  --muted: #b5c2e3;
  --accent: #6ea0ff;
  --ok: #7be7b3;
}
"""
            js = """(function () {
  const root = document.body;
  const toggle = document.getElementById("themeToggle");
  const heartbeat = document.getElementById("heartbeat");
  if (!toggle) return;

  const saved = localStorage.getItem("autodev-theme");
  if (saved === "dark") root.classList.add("dark");

  toggle.addEventListener("click", function () {
    root.classList.toggle("dark");
    localStorage.setItem("autodev-theme", root.classList.contains("dark") ? "dark" : "light");
  });

  if (heartbeat) {
    heartbeat.textContent = "Heartbeat synced at " + new Date().toLocaleTimeString();
  }
})();
"""
            features = ["responsive", "dark-mode", "accessible", "agent-control-layout", "fallback-scaffold"]
            return {"html": html, "css": css, "js": js, "features": features}

        if pack == "studio":
            html = f"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Creative Studio Runtime</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <main class="shell">
    <header class="hero">
      <p class="badge">Studio Mode</p>
      <h1>Creative Delivery Baseline</h1>
      <p class="subtitle">{escaped_goal}</p>
      <button id="themeToggle" class="btn" aria-label="Toggle theme">Toggle theme</button>
    </header>
    <section class="feature-grid" aria-label="Feature cards">
      <article class="card"><h2>Visual rhythm</h2><p>Typographic hierarchy with clear spacing cadence.</p></article>
      <article class="card"><h2>Responsive blocks</h2><p>Cards and sections adapt smoothly across breakpoints.</p></article>
      <article class="card"><h2>Accessible semantics</h2><p>Readable contrast, landmarks, and keyboard-safe actions.</p></article>
    </section>
  </main>
  <script src="app.js"></script>
</body>
</html>
"""
            css = """:root {
  --bg: #fff8f1;
  --surface: #ffffff;
  --text: #2b1b13;
  --muted: #6a5144;
  --accent: #cb5f27;
}
* { box-sizing: border-box; }
body {
  margin: 0;
  font-family: "IBM Plex Sans", "Segoe UI", sans-serif;
  color: var(--text);
  background: radial-gradient(circle at right top, #ffe7d4, var(--bg) 42%);
}
.shell { max-width: 980px; margin: 0 auto; padding: 2rem 1.2rem 3rem; }
.hero { display: grid; gap: 0.75rem; margin-bottom: 1.5rem; }
.badge { margin: 0; color: var(--accent); font-weight: 700; letter-spacing: 0.08em; text-transform: uppercase; }
h1 { margin: 0; font-size: clamp(1.9rem, 4vw, 2.8rem); }
.subtitle { margin: 0; color: var(--muted); max-width: 68ch; }
.btn { width: fit-content; border: 0; border-radius: 10px; padding: 0.65rem 1rem; background: var(--accent); color: #fff; cursor: pointer; }
.feature-grid { display: grid; gap: 1rem; grid-template-columns: repeat(auto-fit, minmax(210px, 1fr)); }
.card { background: var(--surface); border-radius: 14px; padding: 1rem; box-shadow: 0 10px 26px rgba(55, 25, 12, 0.09); }
.card h2 { margin: 0 0 0.55rem; font-size: 1.06rem; }
.card p { margin: 0; color: var(--muted); line-height: 1.55; }
body.dark {
  --bg: #1b1714;
  --surface: #2a231e;
  --text: #fff0e7;
  --muted: #c7b4a8;
  --accent: #ff8e52;
}
"""
            js = """(function () {
  const root = document.body;
  const toggle = document.getElementById("themeToggle");
  if (!toggle) return;
  if (localStorage.getItem("autodev-theme") === "dark") root.classList.add("dark");
  toggle.addEventListener("click", function () {
    root.classList.toggle("dark");
    localStorage.setItem("autodev-theme", root.classList.contains("dark") ? "dark" : "light");
  });
})();
"""
            features = ["responsive", "dark-mode", "accessible", "creative-layout", "fallback-scaffold"]
            return {"html": html, "css": css, "js": js, "features": features}

        html = f"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Product Runtime Baseline</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <main class="shell">
    <header class="hero">
      <p class="badge">Product Mode</p>
      <h1>Continuous Build Baseline</h1>
      <p class="subtitle">{escaped_goal}</p>
      <button id="themeToggle" class="btn" aria-label="Toggle theme">Toggle theme</button>
    </header>
    <section class="grid" aria-label="Highlights">
      <article class="card"><h2>Launch ready</h2><p>Includes semantic HTML, CSS variables, and JS bootstrapping.</p></article>
      <article class="card"><h2>Stable loop</h2><p>Deterministic scaffold keeps autonomous cycles moving safely.</p></article>
      <article class="card"><h2>Upgradeable</h2><p>Easy to extend with richer interactions in next iterations.</p></article>
    </section>
  </main>
  <script src="app.js"></script>
</body>
</html>
"""
        css = """:root {
  --bg: #f6f7fb;
  --surface: #ffffff;
  --text: #1a1f2e;
  --muted: #5d6475;
  --accent: #1769ff;
}
* { box-sizing: border-box; }
body {
  margin: 0;
  font-family: "IBM Plex Sans", "Segoe UI", sans-serif;
  background: radial-gradient(circle at top right, #dfe8ff, var(--bg) 45%);
  color: var(--text);
}
.shell { max-width: 1000px; margin: 0 auto; padding: 2rem 1.25rem 3rem; }
.hero { display: grid; gap: 0.75rem; margin-bottom: 1.5rem; }
.badge { margin: 0; letter-spacing: 0.08em; font-weight: 700; color: var(--accent); text-transform: uppercase; }
h1 { margin: 0; font-size: clamp(1.8rem, 4vw, 2.8rem); }
.subtitle { margin: 0; color: var(--muted); max-width: 70ch; }
.btn { width: fit-content; border: 0; border-radius: 10px; padding: 0.65rem 1rem; background: var(--accent); color: #fff; cursor: pointer; }
.grid { display: grid; gap: 1rem; grid-template-columns: repeat(auto-fit, minmax(210px, 1fr)); }
.card { background: var(--surface); border-radius: 14px; padding: 1rem; box-shadow: 0 10px 30px rgba(11, 30, 80, 0.08); }
.card h2 { margin-top: 0; font-size: 1.05rem; }
.card p { margin: 0; color: var(--muted); line-height: 1.55; }
body.dark {
  --bg: #0f1525;
  --surface: #192239;
  --text: #e9eefc;
  --muted: #b9c3db;
  --accent: #7ea7ff;
}
"""
        js = """(function () {
  const root = document.body;
  const toggle = document.getElementById("themeToggle");
  if (!toggle) return;

  const saved = localStorage.getItem("autodev-theme");
  if (saved === "dark") root.classList.add("dark");

  toggle.addEventListener("click", function () {
    root.classList.toggle("dark");
    localStorage.setItem("autodev-theme", root.classList.contains("dark") ? "dark" : "light");
  });
})();
"""
        features = ["responsive", "dark-mode", "accessible", "fallback-scaffold"]
        return {"html": html, "css": css, "js": js, "features": features}

    def _build_local_scaffold(self, context: Dict[str, Any], iteration: int) -> Dict[str, Any]:
        """Local deterministic fallback to keep loop progressing when model output is empty."""
        project_goal = str(context.get("project_goal", "Modern web app")).strip()
        escaped_goal = project_goal.replace('"', "'")
        pack = self._select_scaffold_pack(project_goal)
        variant = self._build_scaffold_variant(pack, escaped_goal)

        return {
            "files": [
                {"path": "index.html", "content": variant["html"]},
                {"path": "styles.css", "content": variant["css"]},
                {"path": "app.js", "content": variant["js"]},
            ],
            "structure": {
                "type": "spa",
                "framework": "vanilla",
                "features": variant.get("features", ["responsive", "dark-mode", "accessible", "fallback-scaffold"]),
                "fallback_pack": pack,
            },
            "dependencies": [],
            "improvements": [
                "Upgrade visuals and hierarchy once upstream model output is deployable again.",
                "Add domain-specific interactions and API integrations in subsequent iterations.",
            ],
        }
